# 旅游线路规划平台设计与实现 - 核心算法文档

> 版本：v1.0
> 更新日期：2026-01-28
> 适用范围：MVP阶段

---

## 零、版本说明

### 算法演进路线

| 版本 | 算法实现 | 说明 |
|-----|---------|------|
| **MVP v1.0** | AI API（DeepSeek） | 调用AI生成行程，开发快、效果好 |
| **v2.0** | 本地规则引擎 | 脱离API依赖，可控性强 |
| **v2.5** | 混合模式 | AI + 规则，自动降级 |

### 算法抽象层

为支持平滑切换，所有算法实现统一接口：

```java
public interface RecommendationEngine {
    ItineraryPlan generateItinerary(GenerateRequest request, List<Poi> candidates);
    PoiLabel labelPoi(PoiBasicInfo poi);
    String getEngineType();
    boolean isAvailable();
}
```

**MVP阶段**使用 `AIRecommendationEngine`，详见 [07-AI智能服务集成方案.md](./07-AI智能服务集成方案.md)

**以下文档描述的是本地规则算法**，作为：
1. AI API的降级方案
2. v2.0版本的主要实现

---

## 一、算法概述

### 1.1 问题定义

给定用户输入的参数（天数、主题偏好），从POI库中选择合适的景点，合理分配到每天，并计算最优的游玩顺序和交通方式。

### 1.2 算法目标

1. **合理性**：每天的行程安排符合实际游玩时间
2. **紧凑性**：同一天的POI地理位置相近，减少通勤时间
3. **多样性**：行程覆盖不同类型的景点
4. **个性化**：根据主题偏好进行推荐

### 1.3 约束条件

| 约束 | 说明 |
|-----|------|
| 每日游玩时长 | 8-10小时（约480-600分钟） |
| 每日通勤时长 | 不超过120分钟 |
| 每日POI数量 | 3-5个 |
| 起始时间 | 默认早上9:00 |

---

## 二、整体流程

### 2.1 流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户输入                                 │
│                  (days, theme, startPoint)                      │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Step 1: 候选池构建                            │
│                                                                 │
│  • 查询城市下所有上架POI                                          │
│  • 根据theme计算匹配分数                                          │
│  • 按分数排序，取Top N                                            │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Step 2: 分天分配                              │
│                                                                 │
│  • 按区域(area)分组                                              │
│  • 将区域分配给每一天                                             │
│  • 确保每天有合适数量的POI                                        │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Step 3: 日内排序                              │
│                                                                 │
│  • 使用最近邻贪心算法                                             │
│  • 从起点出发，依次选择最近的POI                                   │
│  • 生成当天的游玩顺序                                             │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Step 4: 路线计算                              │
│                                                                 │
│  • 计算相邻POI间的路线信息                                        │
│  • 查询/缓存步行、驾车、公交时间                                   │
│  • 根据距离推荐交通方式                                           │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Step 5: 行程优化                              │
│                                                                 │
│  • 检查每天总时长是否超限                                          │
│  • 如超限则移除低优先级POI                                        │
│  • 重新排序和计算路线                                             │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Step 6: 结果组装                              │
│                                                                 │
│  • 构建行程数据结构                                               │
│  • 生成地图展示数据                                               │
│  • 保存并返回                                                    │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、各步骤详细设计

### 3.1 候选池构建 (CandidatePoolService)

#### 3.1.1 算法描述

从POI库中筛选出适合本次行程的候选景点。

#### 3.1.2 计算规则

**候选池大小**

```
poolSize = max(days * 6, 20)
```

- 至少取20个候选，确保有足够的选择空间
- 每天预留6个候选，以便筛选

**匹配分数计算**

```
score = baseScore + themeBonus + popularityBonus

其中:
- baseScore = 10 (所有POI的基础分)
- themeBonus = 如果POI的tags包含用户选择的theme，+20分
- popularityBonus = 基于POI的热度（可选，MVP暂不实现）
```

#### 3.1.3 伪代码

```java
public List<Poi> buildCandidatePool(String city, String theme, int days) {
    // 1. 查询所有上架POI
    List<Poi> allPois = poiMapper.selectByCity(city, Status.ACTIVE);

    // 2. 如果POI数量不足
    if (allPois.size() < days * 3) {
        throw new BizException("该城市景点数据不足");
    }

    // 3. 计算候选池大小
    int poolSize = Math.max(days * 6, 20);
    poolSize = Math.min(poolSize, allPois.size()); // 不超过总数

    // 4. 计算每个POI的匹配分数
    List<ScoredPoi> scoredList = allPois.stream()
        .map(poi -> {
            int score = 10; // 基础分
            if (theme != null && poi.getTags().contains(theme)) {
                score += 20; // 主题加分
            }
            return new ScoredPoi(poi, score);
        })
        .sorted(Comparator.comparingInt(ScoredPoi::getScore).reversed())
        .collect(Collectors.toList());

    // 5. 取Top N作为候选池
    return scoredList.stream()
        .limit(poolSize)
        .map(ScoredPoi::getPoi)
        .collect(Collectors.toList());
}
```

#### 3.1.4 边界情况处理

| 情况 | 处理方式 |
|-----|---------|
| POI总数 < days * 3 | 抛出异常，提示数据不足 |
| 没有匹配theme的POI | 使用所有POI，忽略theme筛选 |
| 候选池不足poolSize | 使用全部可用POI |

---

### 3.2 分天分配 (DayAllocationService)

#### 3.2.1 算法描述

将候选POI分配到每一天，原则是同一天的POI尽量在相同或相邻区域。

#### 3.2.2 分配策略

**Step 1: 按区域分组**

```
areaGroups = {
    "古城区": [POI1, POI2, POI3],
    "洱海周边": [POI4, POI5],
    "苍山": [POI6, POI7, POI8],
    ...
}
```

**Step 2: 区域分配到天**

```
如果 区域数 >= 天数:
    每天分配 1-2 个区域
    优先分配POI数量多的区域

如果 区域数 < 天数:
    部分天共享同一区域
    将大区域的POI拆分到多天
```

**Step 3: 每天POI数量控制**

```
目标: 每天 3-5 个POI
如果某天POI > 5: 移除低分POI
如果某天POI < 3: 从相邻区域借调POI
```

#### 3.2.3 伪代码

```java
public List<List<Poi>> allocateToDays(List<Poi> candidates, int days) {
    // 1. 按区域分组
    Map<String, List<Poi>> areaGroups = candidates.stream()
        .collect(Collectors.groupingBy(Poi::getArea));

    // 2. 计算每个区域的权重（POI数量）
    List<AreaGroup> sortedAreas = areaGroups.entrySet().stream()
        .map(e -> new AreaGroup(e.getKey(), e.getValue()))
        .sorted(Comparator.comparingInt(a -> -a.getPois().size()))
        .collect(Collectors.toList());

    // 3. 初始化每天的POI列表
    List<List<Poi>> dayGroups = new ArrayList<>();
    for (int i = 0; i < days; i++) {
        dayGroups.add(new ArrayList<>());
    }

    // 4. 分配策略
    int areaCount = sortedAreas.size();

    if (areaCount >= days) {
        // 区域数足够，每天分配主区域
        for (int day = 0; day < days; day++) {
            AreaGroup primaryArea = sortedAreas.get(day % areaCount);
            dayGroups.get(day).addAll(primaryArea.getPois());
        }
    } else {
        // 区域数不足，需要拆分
        int poisPerDay = candidates.size() / days;
        int currentDay = 0;

        for (AreaGroup area : sortedAreas) {
            for (Poi poi : area.getPois()) {
                dayGroups.get(currentDay).add(poi);
                // 当前天满了，切换到下一天
                if (dayGroups.get(currentDay).size() >= poisPerDay && currentDay < days - 1) {
                    currentDay++;
                }
            }
        }
    }

    // 5. 平衡每天的POI数量
    balanceDayGroups(dayGroups);

    return dayGroups;
}

private void balanceDayGroups(List<List<Poi>> dayGroups) {
    int targetMin = 3;
    int targetMax = 5;

    for (int i = 0; i < dayGroups.size(); i++) {
        List<Poi> dayPois = dayGroups.get(i);

        // 如果太多，移除低分的
        while (dayPois.size() > targetMax) {
            Poi lowest = findLowestScorePoi(dayPois);
            dayPois.remove(lowest);
        }

        // 如果太少，从其他天借调
        while (dayPois.size() < targetMin) {
            Poi borrowed = borrowFromOtherDay(dayGroups, i);
            if (borrowed == null) break;
            dayPois.add(borrowed);
        }
    }
}
```

#### 3.2.4 边界情况处理

| 情况 | 处理方式 |
|-----|---------|
| 某区域只有1个POI | 可以单独成天，或与相邻区域合并 |
| 所有POI都在同一区域 | 按POI数量平均分配到各天 |
| 候选池POI总数不足 | 尽量均匀分配，允许每天少于3个 |

---

### 3.3 日内排序 (InDayOrderingService)

#### 3.3.1 算法描述

对每天的POI进行排序，生成最优的游玩顺序。使用**最近邻贪心算法 (Nearest Neighbor)**。

#### 3.3.2 算法原理

```
1. 从起点开始
2. 在未访问的POI中，选择距离当前位置最近的
3. 移动到该POI，标记为已访问
4. 重复步骤2-3，直到所有POI都被访问
```

#### 3.3.3 距离计算

使用 Haversine 公式计算两点间的球面距离：

```java
public static double haversineDistance(double lng1, double lat1, double lng2, double lat2) {
    final double R = 6371000; // 地球半径（米）

    double dLat = Math.toRadians(lat2 - lat1);
    double dLng = Math.toRadians(lng2 - lng1);

    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
               Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
               Math.sin(dLng / 2) * Math.sin(dLng / 2);

    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // 返回米
}
```

#### 3.3.4 伪代码

```java
public List<Poi> orderByNearestNeighbor(List<Poi> dayPois, double startLng, double startLat) {
    if (dayPois.isEmpty()) {
        return Collections.emptyList();
    }

    List<Poi> ordered = new ArrayList<>();
    Set<Long> visited = new HashSet<>();

    // 当前位置
    double currentLng = startLng;
    double currentLat = startLat;

    while (ordered.size() < dayPois.size()) {
        Poi nearest = null;
        double minDistance = Double.MAX_VALUE;

        // 找最近的未访问POI
        for (Poi poi : dayPois) {
            if (visited.contains(poi.getId())) {
                continue;
            }

            double distance = haversineDistance(currentLng, currentLat, poi.getLng(), poi.getLat());
            if (distance < minDistance) {
                minDistance = distance;
                nearest = poi;
            }
        }

        // 添加到结果
        ordered.add(nearest);
        visited.add(nearest.getId());

        // 更新当前位置
        currentLng = nearest.getLng();
        currentLat = nearest.getLat();
    }

    return ordered;
}
```

#### 3.3.5 起点选择策略

| 场景 | 起点选择 |
|-----|---------|
| 用户指定起点 | 使用用户提供的经纬度 |
| 未指定起点 | 使用城市默认起点（大理古城中心） |
| 非首日 | 使用前一天最后一个POI的位置 |

**大理默认起点**：
- 经度: 100.1653
- 纬度: 25.6969
- 位置: 大理古城中心

---

### 3.4 路线计算 (RouteLegService)

#### 3.4.1 算法描述

计算相邻POI之间的交通信息，包括步行、驾车、公交的时间和距离。

#### 3.4.2 缓存策略

```
┌─────────────────────────────────────────────────────────────────┐
│                         查询流程                                 │
└─────────────────────────────────────────────────────────────────┘

        查询路线(fromPoiId, toPoiId)
                    │
                    ▼
            ┌───────────────┐
            │  查询Redis缓存  │
            └───────┬───────┘
                    │
          ┌─────────┴─────────┐
          ▼                   ▼
        命中               未命中
          │                   │
          ▼                   ▼
       返回缓存        ┌───────────────┐
                      │  查询MySQL缓存  │
                      └───────┬───────┘
                              │
                    ┌─────────┴─────────┐
                    ▼                   ▼
                  命中               未命中
                    │                   │
                    ▼                   ▼
             写入Redis缓存       ┌───────────────┐
                  │             │  调用高德API   │
                  ▼             └───────┬───────┘
               返回结果                 │
                              ┌─────────┴─────────┐
                              ▼                   ▼
                            成功               失败
                              │                   │
                              ▼                   ▼
                       写入MySQL和Redis       返回null(降级)
                              │
                              ▼
                           返回结果
```

#### 3.4.3 并发调用

对于同一对POI，并发调用三种交通方式的API：

```java
public RouteInfo calculateRoute(Poi from, Poi to) {
    String cacheKey = buildCacheKey(from.getId(), to.getId());

    // 1. 查缓存
    RouteInfo cached = getFromCache(cacheKey);
    if (cached != null) {
        return cached;
    }

    // 2. 并发调用高德API
    CompletableFuture<Integer> walkFuture = CompletableFuture.supplyAsync(() ->
        amapService.getWalkDuration(from.getLng(), from.getLat(), to.getLng(), to.getLat())
    );

    CompletableFuture<Integer> driveFuture = CompletableFuture.supplyAsync(() ->
        amapService.getDriveDuration(from.getLng(), from.getLat(), to.getLng(), to.getLat())
    );

    CompletableFuture<Integer> transitFuture = CompletableFuture.supplyAsync(() ->
        amapService.getTransitDuration(from.getLng(), from.getLat(), to.getLng(), to.getLat())
    );

    // 3. 等待所有结果
    CompletableFuture.allOf(walkFuture, driveFuture, transitFuture).join();

    // 4. 构建结果
    RouteInfo routeInfo = RouteInfo.builder()
        .fromPoiId(from.getId())
        .toPoiId(to.getId())
        .distanceMeter(calculateDistance(from, to))
        .walkDurationSec(walkFuture.join())
        .driveDurationSec(driveFuture.join())
        .transitDurationSec(transitFuture.join())
        .recommendMode(determineRecommendMode(walkFuture.join(), calculateDistance(from, to)))
        .build();

    // 5. 写缓存
    saveToCache(cacheKey, routeInfo);

    return routeInfo;
}
```

#### 3.4.4 智能交通方式推荐

对于每个路段（A→B），需要独立判断最佳交通方式。决策流程：

**Step 1: 获取多种交通方式数据**

对每对相邻 POI，并发调用高德 API 获取：
- 步行：距离、耗时、路径坐标
- 驾车：距离、耗时、路径坐标
- 公交：距离、耗时、换乘次数、路径坐标

**Step 2: 应用决策规则**

```java
public String recommendMode(int walkSec, int driveSec, int transitSec,
                            int transitTransfers, double distanceM) {
    // 规则1: 步行15分钟内，优先步行
    if (walkSec <= 900) {
        return "walk";
    }

    // 规则2: 距离超过5公里，或公交换乘太多，推荐驾车
    if (distanceM > 5000 || transitTransfers >= 3) {
        return "drive";
    }

    // 规则3: 公交时间在驾车1.5倍以内，推荐公交
    if (transitSec > 0 && transitSec <= driveSec * 1.5) {
        return "transit";
    }

    // 规则4: 默认驾车
    return "drive";
}
```

**决策规则说明**：

| 优先级 | 条件 | 推荐方式 | 理由 |
|--------|------|----------|------|
| 1 | 步行时间 ≤ 15分钟 | 步行 | 短距离步行体验更好 |
| 2 | 距离 > 5km 或 换乘 ≥ 3次 | 驾车 | 长距离或复杂公交不便 |
| 3 | 公交时间 ≤ 驾车时间×1.5 | 公交 | 经济环保 |
| 4 | 其他情况 | 驾车 | 默认选择 |

**Step 3: 存储路段数据**

每个路段独立存储，数据结构：

```json
{
  "from": "洱海公园",
  "to": "大理古城",
  "distance": 3200,
  "recommendMode": "transit",
  "walkDurationSec": 2400,
  "driveDurationSec": 480,
  "transitDurationSec": 720,
  "transitTransfers": 0,
  "path": [[100.1856, 25.6892], [100.1867, 25.6901], ...]
}
```

#### 3.4.5 推荐交通方式（简化版）

MVP 阶段使用简化的距离判断规则：

```java
public String determineRecommendMode(Integer walkDurationSec, double distanceMeter) {
    // 规则1: 距离 <= 1km 推荐步行
    if (distanceMeter <= 1000) {
        return "walk";
    }

    // 规则2: 距离 1-3km 根据步行时间决定
    if (distanceMeter <= 3000) {
        // 步行时间 <= 30分钟 推荐步行
        if (walkDurationSec != null && walkDurationSec <= 1800) {
            return "walk";
        }
        return "transit";
    }

    // 规则3: 距离 > 3km
    if (distanceMeter <= 10000) {
        return "transit"; // 3-10km 推荐公交
    }

    return "drive"; // > 10km 推荐驾车
}
```

#### 3.4.5 降级处理

| API失败情况 | 降级策略 |
|------------|---------|
| 步行API失败 | 根据距离估算：距离(米) / 1.2 = 秒数 |
| 驾车API失败 | 根据距离估算：距离(米) / 8 = 秒数 |
| 公交API失败 | 使用驾车时间 * 1.5 估算 |
| 全部失败 | 仅使用距离估算，标记为"暂不可用" |

---

### 3.5 行程优化 (ItineraryOptimizeService)

#### 3.5.1 优化目标

确保每天的行程在合理的时间范围内。

#### 3.5.2 时间约束

```
每日可用时间 = 10小时 = 600分钟

每日总耗时 = Σ(POI游玩时长) + Σ(POI间通勤时长)

如果 每日总耗时 > 600分钟:
    需要移除POI
```

#### 3.5.3 优化算法

```java
public List<Poi> optimizeDayPlan(List<Poi> orderedPois, List<RouteInfo> routes, String theme) {
    final int MAX_DAILY_MINUTES = 600; // 10小时

    // 1. 计算当前总时长
    int totalMinutes = calculateTotalMinutes(orderedPois, routes);

    // 2. 如果未超限，直接返回
    if (totalMinutes <= MAX_DAILY_MINUTES) {
        return orderedPois;
    }

    // 3. 需要优化，移除POI
    List<Poi> result = new ArrayList<>(orderedPois);

    while (totalMinutes > MAX_DAILY_MINUTES && result.size() > 3) {
        // 找到优先级最低的POI
        Poi toRemove = findLowestPriorityPoi(result, theme);
        result.remove(toRemove);

        // 重新排序
        result = reorderPois(result);

        // 重新计算路线和时长
        List<RouteInfo> newRoutes = calculateRoutes(result);
        totalMinutes = calculateTotalMinutes(result, newRoutes);
    }

    return result;
}

private Poi findLowestPriorityPoi(List<Poi> pois, String theme) {
    // 优先移除:
    // 1. 不匹配theme的POI
    // 2. 游玩时长最短的POI
    // 3. 造成最长通勤的POI

    return pois.stream()
        .min(Comparator.comparingInt(poi -> calculatePriority(poi, theme)))
        .orElse(pois.get(pois.size() - 1));
}

private int calculatePriority(Poi poi, String theme) {
    int priority = 0;

    // 主题匹配加分
    if (theme != null && poi.getTags().contains(theme)) {
        priority += 100;
    }

    // 游玩时长加分（时长越长，优先级越高）
    priority += poi.getVisitDuration() / 10;

    return priority;
}
```

#### 3.5.4 最少POI保证

- 每天至少保留3个POI
- 如果3个POI仍超时，保留并给出提示"今日行程较紧凑"

---

### 3.6 结果组装

#### 3.6.1 数据结构

```java
@Data
public class ItineraryResponse {
    private Long itineraryId;
    private String city;
    private Integer days;
    private String theme;
    private List<DayPlan> dayList;
    private MapData mapData;
}

@Data
public class DayPlan {
    private Integer dayIndex;
    private List<DayItem> items;
    private Integer totalVisitMinutes;   // 总游玩时长
    private Integer totalTransitMinutes; // 总通勤时长
}

@Data
public class DayItem {
    private Integer orderIndex;
    private PoiInfo poi;
    private RouteToNext routeToNext; // 到下一个POI的路线，最后一个为null
}

@Data
public class RouteToNext {
    private Integer distanceMeter;
    private Integer walkDurationSec;
    private Integer driveDurationSec;
    private Integer transitDurationSec;
    private String recommendMode;
}

@Data
public class MapData {
    private double[] center;
    private Integer zoom;
    private List<MarkerInfo> markers;
    private List<PolylineInfo> polylines;
}
```

---

## 四、性能优化

### 4.1 并发控制

使用信号量限制同时调用高德API的并发数：

```java
@Service
public class AmapService {

    // 限制最多10个并发请求
    private final Semaphore semaphore = new Semaphore(10);

    // 超时时间
    private static final Duration TIMEOUT = Duration.ofSeconds(5);

    public Integer getWalkDuration(double fromLng, double fromLat, double toLng, double toLat) {
        try {
            if (!semaphore.tryAcquire(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)) {
                log.warn("高德API并发超限，降级处理");
                return estimateWalkDuration(fromLng, fromLat, toLng, toLat);
            }

            try {
                return doGetWalkDuration(fromLng, fromLat, toLng, toLat);
            } finally {
                semaphore.release();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return estimateWalkDuration(fromLng, fromLat, toLng, toLat);
        }
    }
}
```

### 4.2 批量路线计算

一次性计算一天内所有相邻POI的路线：

```java
public List<RouteInfo> calculateDayRoutes(List<Poi> orderedPois) {
    if (orderedPois.size() < 2) {
        return Collections.emptyList();
    }

    // 构建所有需要计算的POI对
    List<PoiPair> pairs = new ArrayList<>();
    for (int i = 0; i < orderedPois.size() - 1; i++) {
        pairs.add(new PoiPair(orderedPois.get(i), orderedPois.get(i + 1)));
    }

    // 先批量查询缓存
    Map<String, RouteInfo> cached = batchGetFromCache(pairs);

    // 筛选出需要调用API的
    List<PoiPair> toFetch = pairs.stream()
        .filter(p -> !cached.containsKey(p.getCacheKey()))
        .collect(Collectors.toList());

    // 并发调用API
    List<CompletableFuture<RouteInfo>> futures = toFetch.stream()
        .map(pair -> CompletableFuture.supplyAsync(() ->
            calculateRoute(pair.getFrom(), pair.getTo())))
        .collect(Collectors.toList());

    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

    // 合并结果
    Map<String, RouteInfo> fetched = futures.stream()
        .map(CompletableFuture::join)
        .filter(Objects::nonNull)
        .collect(Collectors.toMap(r -> buildCacheKey(r.getFromPoiId(), r.getToPoiId()), r -> r));

    // 按原顺序返回结果
    return pairs.stream()
        .map(p -> {
            String key = p.getCacheKey();
            return cached.containsKey(key) ? cached.get(key) : fetched.get(key);
        })
        .collect(Collectors.toList());
}
```

### 4.3 超时控制

整个行程生成设置总超时：

```java
@Service
public class ItineraryGenerateService {

    private static final Duration TOTAL_TIMEOUT = Duration.ofSeconds(15);

    public ItineraryResponse generate(GenerateRequest request) {
        CompletableFuture<ItineraryResponse> future = CompletableFuture.supplyAsync(() ->
            doGenerate(request)
        );

        try {
            return future.get(TOTAL_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            log.error("行程生成超时", e);
            throw new BizException("行程生成超时，请稍后重试");
        } catch (Exception e) {
            log.error("行程生成失败", e);
            throw new BizException("行程生成失败，请稍后重试");
        }
    }
}
```

---

## 五、算法局限性与未来优化

### 5.1 当前局限性

| 局限 | 说明 | 解决版本 |
|-----|------|---------|
| 最近邻算法非最优 | 贪心算法可能产生交叉路径 | v2.0 使用2-opt优化 |
| 未考虑营业时间 | 景点可能在到达时已关闭 | v1.5 时间窗口约束 |
| 未考虑用餐时间 | 没有在行程中安排午餐/晚餐时间 | v1.5 自动插入用餐 |
| 未考虑返回住所 | 每天结束时没有规划回程 | v2.0 闭环路径优化 |

### 5.2 未来优化方向

详细规划请参考 [08-未来规划与扩展设计.md](./08-未来规划与扩展设计.md)

**v2.0 算法升级**：
- 使用2-opt算法优化路径，消除交叉
- 基于用户画像的个性化评分
- 支持时间窗口约束（营业时间）

**v2.5 智能化**：
- 混合推荐（AI + 规则）
- 实时交通/天气调整
- 学习用户反馈优化权重

---

## 六、测试用例

### 6.1 单元测试

| 测试项 | 输入 | 预期输出 |
|-------|------|---------|
| 候选池-正常 | city=大理, days=3, theme=古镇 | 返回18个POI，古镇标签优先 |
| 候选池-无主题 | city=大理, days=3, theme=null | 返回18个POI，按默认排序 |
| 分天分配-区域足够 | 6个区域, 3天 | 每天2个区域 |
| 分天分配-区域不足 | 2个区域, 3天 | 部分天共享区域 |
| 日内排序-正常 | 5个POI | 返回最近邻顺序 |
| 时间优化-超时 | 6个POI, 总时长700分钟 | 返回5个POI, 总时长<=600 |

### 6.2 集成测试

| 测试项 | 条件 | 预期结果 |
|-------|------|---------|
| 3天行程生成 | 正常网络 | 8秒内完成 |
| 高德API部分失败 | 模拟50%超时 | 使用降级估算，正常返回 |
| 高德API全部失败 | 模拟全超时 | 使用距离估算，标记暂不可用 |
| 并发生成 | 10个并发请求 | 全部成功，无超时 |
